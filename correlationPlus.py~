#!/usr/bin/env python
"""
Program Name: Cross-correlation Plotting Program (I'll find a fancy name later!)
Author      : Mustafa TEKPINAR
Email       : tekpinar@buffalo.edu
Copyright   : Mustafa Tekpinar - 2019
License     : BSD

Purpose     : This is a small program to automatize plotting of normalied dynamical cross-
correlations obtained from molecular dynamics simulations or elastic network 
models. I just didn't like the way current programs are doing it and I wrote something 
for myself. I hope it may help the others also!
"""

import matplotlib.pyplot as plt
import matplotlib.collections as collections
import numpy as np
import getopt
import sys
import matplotlib
from prody import *
from collections import Counter

def usage():
    """
    Show how to use the small program!
    """
    print("\nExample usage:\n")
    print("python nDCCPotGeneral.py -i 4z90_cross-correlations.txt -s ' ' -p 4z90.pdb -o 4z90_cross-correlations\n")
    print("Arguments: -i: A file containing normalized dynamical cross correlations in matrix format.")
    print("           -s: A string for the title of the plot.")
    print("           -p: PDB file of the protein.")
    print("           -o: This will be your output file. Output is in png format.")

def cmap_discretize(cmap, N):
    """Return a discrete colormap from the continuous colormap cmap.
    
        cmap: colormap instance, eg. cm.jet. 
        N: number of colors.
    
    Example
        x = resize(arange(100), (5,100))
        djet = cmap_discretize(cm.jet, 5)
        imshow(x, cmap=djet)
    """

    if type(cmap) == str:
        cmap = get_cmap(cmap)
    colors_i = np.concatenate((np.linspace(0, 1., N), (0.,0.,0.,0.)))
    colors_rgba = cmap(colors_i)
    indices = np.linspace(0, 1., N+1)
    cdict = {}
    for ki,key in enumerate(('red','green','blue')):
        cdict[key] = [ (indices[i], colors_rgba[i-1,ki], colors_rgba[i,ki]) for i in range(N+1) ]
    # Return colormap object.
    return matplotlib.colors.LinearSegmentedColormap(cmap.name + "_%d"%N, cdict, 1024)

##################### HANDLE ARGUMENTS ##########################################                                                                           
opts, args = getopt.getopt(sys.argv[1:],"hi:o:s:p:",["inp=", "out=", "sel=", "pdb="])
inp_file = None
pdb_file = None
out_file = None
sel_type = None
norm_status = 0
try:
    opts, args = getopt.getopt(sys.argv[1:],"hi:o:s:p:",["inp=", "out=", "sel=", "pdb="])
except getopt.GetoptError:
    usage()
for opt, arg in opts:
    if opt == '-h':
        usage()
        sys.exit(-1)
    elif opt in ("-i", "--inp"):
        inp_file = arg
    elif opt in ("-o", "--out"):
        out_file = arg
    elif opt in ("-s", "--sel"):
        sel_type = arg
    elif opt in ("-p", "--pdb"):
        pdb_file = arg
    else:
        assert False, usage()

if inp_file==None or out_file==None:
    usage()
    sys.exit(-1)

print("Input file is ", inp_file)
print("Pdb file is ", pdb_file)
print("Output is ", out_file)
print("Your title is ", sel_type)


calphaAtoms = parsePDB(pdb_file, subset='ca')

#chains = Counter(calphaAtoms.getChids()).keys()

#chainLengths = Counter(calphaAtoms.getChids()).values()


##########################################################################
#Read data and assign to a matrix
cc=np.loadtxt(inp_file, dtype=float)
n=len(cc)
##########################################################################
#Set residue interface definitions
fig=plt.figure()
plt.rcParams['font.size'] = 16
ax=fig.add_subplot(1,1,1)

plt.xlabel('Residue indices')
plt.ylabel('Residue indices')
plt.title(sel_type, y=1.08)

selection=[]
for i in range(0, n):
    selection.append(i)

#selection_reorder=np.zeros(len(selection), np.int)
selection_tick_labels=[]

print(calphaAtoms.getChids())
# for i in Counter(calphaAtoms.getChids()).keys():
#     print(i)

myList = list(Counter(calphaAtoms.getChids()).keys())
#print(myList)

selection_reorder = []
selection_tick_labels = []
selection_tick_labels.append(str(calphaAtoms.getResnums()[0]))
selection_reorder.append(0)
tempVal = 0
for i in Counter(calphaAtoms.getChids()).values():
    tempVal = tempVal + i
    selection_reorder.append(tempVal)
    selection_tick_labels.append(str(i))

print(selection_reorder)


major_nums=[]
major_labels=[]
major_nums.extend(selection_reorder)
major_labels.extend(selection_tick_labels)

y_nums=[]
y_labels=[]

y_nums.extend(selection_reorder)
y_labels.extend(selection_tick_labels)

##########################################################################
#Set plotting parameters

#plt.rcParams['axes.titlepad'] = 20
ax.autoscale(False)
ax.set_aspect('equal')

#ax.set_xticks(major_nums, major_labels, rotation=45, minor=False)
plt.xticks(major_nums, major_labels, size=12, rotation=45)
plt.yticks(major_nums, major_labels, size=12)

#ax.xaxis.set_tick_params(width=2, length=5, labelsize=12, minor=False)
#ax.yaxis.set_tick_params(width=2, length=5)

plt.axis([0, n, 0, n])
ax.tick_params(which='major', width=2, length=5)
ax.tick_params(which='minor', width=1, length=3)
#ax.xaxis.set_minor_locator(matplotlib.ticker.FixedLocator([187, 497, 807, 1117, 1427]))
#ax.yaxis.set_minor_locator(matplotlib.ticker.FixedLocator([187, 497, 807, 1117, 1427]))
#ax.xaxis.set_minor_formattor(matplotlib.ticker.FixedLocator(['194', '194', '194', '194', '194']))
#print("Min value")
#print("Row Index of min value")
#print(np.argmin(cc_sub, 0))

#print("Column Index of min value")
#print(np.argmin(cc_sub, 1))
         
jet=plt.get_cmap('jet') 
djet = cmap_discretize(jet, 8)

plt.imshow(np.matrix(cc), cmap=djet)
plt.clim(-1.0, 1.0)


fig.set_size_inches(8.0, 5.5, forward=True)

position=fig.add_axes([0.85, 0.15, 0.03, 0.70])
cbar=plt.colorbar(cax=position)

cbar.set_ticks([-1.00, -0.75, -0.50, -0.25, 0.00, 0.25, 0.50, 0.75, 1.00])

for t in cbar.ax.get_yticklabels():
    t.set_horizontalalignment('right')   
    t.set_x(4.0)


#Add chain borders to the plot
for i in range(len(selection_reorder)-1):
    beginningPoint = selection_reorder[i]/selection_reorder[-1]
    endingPoint = selection_reorder[i+1]/selection_reorder[-1]
    middlePoint = (float(beginningPoint)+float(endingPoint))/2.0
    if(i%2==0):
        #x axis
        ax.annotate('', xy=(beginningPoint, 1.03), xycoords='axes fraction', \
                    xytext=(endingPoint, 1.03), arrowprops=dict(linewidth = 2., arrowstyle="-", color='black'))

        #y axis
        ax.annotate('', xy=(1.04, beginningPoint), xycoords='axes fraction', \
                    xytext=(1.04, endingPoint), arrowprops=dict(linewidth = 2., arrowstyle="-", color='gray'))  

    elif(i%2==1):
        #x axis
        ax.annotate('', xy=(beginningPoint, 1.03), xycoords='axes fraction', \
                    xytext=(endingPoint, 1.03), arrowprops=dict(linewidth = 2., arrowstyle="-", color='gray'))
        
        #y axis
        ax.annotate('', xy=(1.04, beginningPoint), xycoords='axes fraction', \
                    xytext=(1.04, endingPoint), arrowprops=dict(linewidth = 2., arrowstyle="-", color='black')) 

    ax.annotate(myList[i], xy=(0, 1.04), xycoords='axes fraction', xytext=(middlePoint-0.015, 1.04), size=14, color='black')
    ax.annotate(myList[i], xy=(1.05, 0), xycoords='axes fraction', xytext=(1.05, middlePoint-0.015), rotation=90, size=14, color='black')
    print(middlePoint)

plt.tight_layout()       
plt.savefig(out_file+'.png', dpi=200)
#plt.show()
